{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-18","excerpt":""},{"title":"","text":"你看，那个人又偷偷溜走了..","path":"about/index.html","date":"07-18","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-18","excerpt":""}],"posts":[{"title":"前端综合总结","text":"内置类型JS中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象(Object) 基本类型有六种：null, undefined, boolean, number, string, symbol。 其中JS的数字类型是浮点类型的，没有整形。并且浮点类型基于IEEE 754标准实现，在使用中会遇到某些BUG。 NaN 也属于 number 类型，并且NaN 不等于自身。 NaN == NaN //false 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型。 let a = 111 //字面量，不是number 类型 Object 是引用类型，就是复杂类型，在使用过程中会遇到 浅拷贝和深拷贝的问题。 Typeoftypeof 对于基本类型来说，除了 null 都可以显示正确的类型 null的类型显示为object1234567typeof 1 //&apos;number&apos;typeof &apos;1&apos; //&apos;string&apos;typeof undefined //&apos;undefined&apos;typeof true //&apos;boolean&apos;typeof Symbol() //&apos;symbol&apos;typeof b //b 没有声明，但是还是会显示 undefinedtypeof null //&apos;object&apos; typeof 对于对象，除了函数都会显示 object123typeof [] //&apos;object&apos;typeof &#123;&#125; //&apos;object&apos;typeof function()&#123;&#125; //&apos;function&apos; 如果我们想要准确的获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就能获得类似 [Object Type]的字符串。 类型转换转Boolean除了 undefined, null, 0, false, ‘’, NaN, -0这七种，其他所有的值都为true，包括所有对象。对象转基本类型对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。 并且这两个方法也是可以重写的。 四则运算符如果是加法运算，其中一方是字符串类型，就会把另一个值也转为字符串类型。 其他运算只要其中一方是数字，那么另外一方就会被转为数字。 [1, 2]+[2, 1] //‘1,22,1’ ‘a’+ +’b’ //‘aNaN’ 原型每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 原型是什么？ 在javascript中原型是一个prototype对象，用于表示类型之间的关系。 原型链是什么？ javascript中万物都是对象， 对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在javascript中是可以通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，叫做原型链。 每个对象都有proto属性，指向创建该对象的构造函数的原型。 对象可以通过proto 来寻找不属于该对象的属性， proto将对象连接起来组成了原型链。 new 新生成了一个对象。 链接到原型。 绑定了this。 返回新对象 在调用 new 的过程中会发生以上四件事，我们试着自己来实现一个 new123456789101112function create() &#123; // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) //链接到原型 obj.__proto__ = Con.prototype //绑定 this 执行构造函数 let result = Con.apply(obj, arguments) //确保 new 出来的是个对象 return typeof result === &apos;object&apos;?result:obj&#125; 对于实例对象来说，都是通过new 产生的，无论是 function Foo() 还是 let a = { b: 1 }。 instanceofinstanceof 可以正确的判断对象的类型， 其内部机制是通过对象的原型链中是不是能找到类型的prototype。 thisthis永远指向最后调用他的那个对象。 new的优先级最高 其次是call, apply, bind 改变 this 箭头函数的this是取决于上级不是箭头函数的函数的this 执行上下文(作用域)当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval执行上下文 变量提升： 函数 优先级 比变量 高。在提升的过程中，相同的函数会覆盖上一个函数。 let不能在声明前使用，会报错 什么是闭包？函数A 返回一个函数B，并且函数B中使用了函数A的变量，函数B就是闭包。 深浅拷贝123456let a = &#123; age: 1&#125;let b = aa.age = 2console.log(b.age) //2 如果把一个变量赋值给一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应的改变。 通常我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。 浅拷贝可以用Object.assign来解决这个问题123456let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) //1 还可以通过展开运算符…来解决12345678let a = &#123; age: 1&#125;let b = &#123; ...a&#125;a.age = 2console.log(b.age) //1 但是当我们遇到如下情况就需要使用到深拷贝了123456789let a = &#123; age: 1, jobs: &#123; first: &apos;FE&apos; &#125;&#125;let b = &#123;...a&#125;a.jobs.first = &apos;native&apos;console.log(b.jobs.first) //native 如果接下去的值中还有对象的话，就需要引入深拷贝JSON.parse(JSON.stringify(object))123456789let a = &#123; age: 1, jobs: &#123; first: &apos;EF&apos; &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = &apos;native&apos;console.log(b.jobs.first) //EF 模块化ES612345678file a.jsexport function a() &#123;&#125;export function b() &#123;&#125;file b.jsexport default function() &#123;&#125;import &#123;a, b&#125; from &apos;./a.js&apos;import XXX from &apos;./b.js CommonCommonJS 是Node独有的规范12345678a.jsmodule.exports = &#123; a: 1&#125;b.jsvar module = require(&apos;./a.js&apos;)module.a //1 AMDAMD是由RequireJS 提出的12345678910define([&apos;./a&apos;, &apos;./b&apos;], function(a,b)&#123; a.do() b.do()&#125;)define(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() var b = require(&apos;./b&apos;) b.doSomething()&#125;) 防抖在一段时间内的多次执行变成最后一次执行 节流将多次执行变成每隔一段时间执行 继承ES5模式：1234567891011121314function Super() &#123;&#125;Super.prototype.getNumber = function() &#123; return 1&#125;function Sub() &#123;&#125;let s = new Sub()Sub.prototype = Object.create(Super.prototype, &#123; constructor: &#123; value: Sub, enumerable: false, writable: true, configurable: true &#125;&#125;) 以上继承实现思路就是将子类的原型设置为父类的原型 ES6:1234567class MyDate extends Date &#123; test () &#123; return this.getTime() &#125;&#125;let myDate = new MyDate()myDate.test() call,apply,bind区别Promise实现Promise 是 ES6新增的语法，解决了回调地狱的问题。 可以把Promise看成一个状态机。初始是pending状态，可以通过函数resolve 和 reject， 将状态转变为 resolved或者rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个Promise实例，并且该返回值是一个新的实例而不是之前的实例。","path":"2018/07/24/jssum/","date":"07-24","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc90e8616022f?w=1920&h=1080&f=jpeg&s=84587"},{"title":"React加载stylus文件之eject","text":"上篇知道了如何自定义配置webpack,接下来就让我们用简单一些的方法来实现使用stylus等功能。安装stylus依赖：1yarn add stylus stylus-loader 在webpack配置依赖，如果要手动配置webpack的话，React必须先把配置Eject出来：1yarn run eject react-cli会询问你是否执行操作，并提示你这个操作是不可逆的。输入y继续这个时候如果eject的该项目是在本地的一个git仓库里的，而且这个仓库里还有文件未上传到远程。那么恭喜你，你eject会失败，它会告诉你必须要把本地这个仓库里的文件未更改的状态下才能把webpack配置eject出来。成功以后项目根目录下会弹射出一个config文件夹和一个scripts文件夹，同时package.json里的相关配置也会改变在弹射出来的config文件夹下找到webpack.config.dev.js:1234567891011找到module.rules.oneOf,里面有一个css的配置项，把styl加进去:test: /\\.(css|styl)$/,然后在use中加入以下配置代码：&#123; loader: require.resolve(&apos;stylus-loader&apos;), options: &#123; sourceMap: true &#125;&#125;;滑到oneOf的最下面，找到exclude，将styl加进去：exclude: [/\\.(js|jsx|mjs)$/, /\\.html$/, /\\.json$/,/\\.styl$/], 然后记住要重新yarn安装一下依赖，最后输入yarn start就能成功启动了(可以直接引入styl文件)，这个时候还会出现一个postcss的提示，原来他是一个强大的东西，autoprefixer也只是他其中的一个插件安装postcss-loader:1yarn add postcss-loader 最后就会惊喜的发现关于css的浏览器兼容性问题的浏览器前缀会自动帮你加上 我的demo地址","path":"2018/07/22/eject/","date":"07-22","excerpt":""},{"title":"React定制webpack 工作流","text":"不使用eject,自定义webpack配置使用stylus以及alias@别名和autoprefixer前缀 在项目根目录下新建一个scripts文件夹。 在scripts文件夹中新建customized-build.js、overrides-config.base.js、overrides-config.dev.js、overrides-config.prod.js四个文件 安装rewire来实现运行时动态替换react-scripts // yarn add rewire proxyquire –save 在customized-build.js中加入以下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243var rewire = require(&apos;rewire&apos;);var proxyquire = require(&apos;proxyquire&apos;);switch(process.argv[2]) &#123; case &apos;start&apos;: rewireModule(&apos;react-scripts/scripts/start.js&apos;, loadCustomizer(&apos;./overrides-config.dev&apos;)); break; case &apos;build&apos;: rewireModule(&apos;react-scripts/scripts/build.js&apos;, loadCustomizer(&apos;./overrides-config.prod&apos;)); break; default: console.log(&apos;customized-build only supports &quot;start&quot;, &quot;build&quot;, and &quot;test&quot; options.&apos;); process.exit(-1);&#125;function loadCustomizer(module) &#123; try &#123; return require(module); &#125; catch(e) &#123; if(e.code !== &quot;MODULE_NOT_FOUND&quot;) &#123; throw e; &#125; &#125; // If the module doesn&apos;t exist, return a // noop that simply returns the config it&apos;s given. return config =&gt; config;&#125;function rewireModule(modulePath, customizer) &#123; // Load the module with `rewire`, which allows modifying the // script&apos;s internal variables. let defaults = rewire(modulePath); // Reach into the module, grab its global &apos;config&apos; variable, // and pass it through the customizer function. // The customizer should *mutate* the config object, because // react-scripts imports the config as a `const` and we can&apos;t // modify that reference. let config = defaults.__get__(&apos;config&apos;); customizer(config);&#125; 安装poststylus,autoprefixer只是其中的一个插件，yarn add poststylus -D开发环境替换配置：stylus 和 alias(也就是vue中的@路径别名)，在dev.js文件中引入以下代码：12345678910111213const baseConfig = require(&apos;./overrides-config.base&apos;)module.exports = function(config) &#123; let alias = config.resolve.alias; alias[&quot;@&quot;] = baseConfig.rootPath; let loaderList = config.module.rules[1].oneOf; loaderList.splice(loaderList.length-1, 0, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;] &#125;) config.plugins.push(baseConfig.stylusLoaderOptionsPlugin);&#125; 在base.js文件中引入以下代码：12345678910111213141516171819202122232425262728293031const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;)const poststylus = require(&apos;poststylus&apos;)const autoprefixer = require(&apos;autoprefixer&apos;)function resolve(dir) &#123; return path.join(__dirname, &apos;..&apos;, dir);&#125;module.exports.rootPath = resolve(&apos;src&apos;)module.exports.stylusLoaderOptionsPlugin = new webpack.LoaderOptionsPlugin(&#123; options: &#123; stylus: &#123; use: [ poststylus([ require(&apos;postcss-flexbugs-fixes&apos;), autoprefixer(&#123; browsers: [ &apos;&gt;1%&apos;, &apos;last 4 versions&apos;, &apos;Firefox ESR&apos;, &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway ], flexbox: &apos;no-2009&apos;, &#125;) ]) ] &#125; &#125;&#125;); 安装stylus依赖，yarn add stylus stylus-loader –save 还需要创建一个config-overrides.prod.js文件具有相同的内容。开发过程中使用的是dev文件(例如npm start)，在构建期间使用prod文件(例如，npm run build) 最后，要让这些新代码生效，你需要更改package.json，调用这些新的脚本，而不是默认的react-scripts的脚本。要做到这一点，可以用以下方法替换“start”、“build”和“test”12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node scripts/customized-build start&quot;, &quot;build&quot;: &quot;node scripts/customized-build build&quot;, &quot;test&quot;: &quot;node scripts/customized-build test --env=jsdom&quot;,&#125;, 注意⚠️：每次修改配置文件都要重启一下yarn start","path":"2018/07/22/rmusic/","date":"07-22","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc91009dfd658?w=1920&h=1080&f=jpeg&s=266732"},{"title":"聊聊HTTPS","text":"HTTP实现原理：一个故事讲完https 什么是 HTTPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTP 与 HTTPS 的区别 HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密 HTTP 的端口号是 80，HTTPS 是 443 HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费 HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。 为什么要使用 HTTPS 建立一个信息安全通道，来保证数据传输的安全 确认网站的真实性，防止钓鱼网站","path":"2018/07/21/https/","date":"07-21","excerpt":""},{"title":"this、apply、call、bind","text":"this、apply、call、bind这是一个面试经典问题，是ES5时代的一个坑，我们利用ES6的箭头函数可以极大的避免这个this指向错误的结果 ES5中，this的指向其实可以用一句话来概括，只要牢记这句话，犯错的概率就会大大降低。 this 永远指向最后调用它的那个对象 怎么改变this的指向改变 this 的指向一共有以下4种方法： 使用ES6的箭头函数 在函数内部定义一个that = this 使用apply、call、bind 使用new来实例化一个对象 12345678910111213141516var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function () &#123; this.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //this.func1 is not a function 上述题中很多人会想当然的觉得答案是输出”dance”，然而在不使用箭头函数的情况下，是会报错的。因为在this.func1()中的作用域是在setTimeout中而不是在func2中，因此最后调用 setTimeout 的对象是window，window中不存在func1函数，所以报错了 1. 箭头函数众所周知，ES6的箭头函数是可以避免ES5中使用this所遇到的指向错误的坑的。箭头函数的this始终指向上层作用域的this。1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( ()=&gt; &#123; this.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //dance 2. 在函数内部定义一个 that = this如果不使用箭头函数，那通常我们都会选择这种简单的方法，先在函数内部定义一个that，来把this的指向赋值给它，然后在这个函数的内部都使用这个that，这样this的指向就不会改变了。123456789101112131415161718var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; var that = this; setTimeout( function() &#123; that.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //dance 3. 使用apply、call、bind使用apply、call、bind函数也是可以改变this的指向的 使用apply1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.apply(xiaoming),1000) &#125;&#125;;xiaoming.func2() //dance 使用call1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.call(xiaoming),1000) &#125;&#125;;xiaoming.func2() //dance 使用bind1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.bind(xiaoming)(),1000) &#125;&#125;;xiaoming.func2() //dance apply、call、bind区别 apply和call的区别:其实apply和call的区别不大，只是参入的第二个参数类型不同。 1234567891011call:var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.call(a,1,2) //3 1234567891011apply: var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.apply(a,[1,2]) //3 12345678910bind:var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.bind(a,1,2) 我们发现bind并没有输出，因为bind()方法是会创建一个新的函数，所以我们必须要手动去调用：123456789var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.bind(a,1,2)() //3 JS中的函数调用方式JS中一共有4种调用方式： 作为一个函数调用 函数作为对象中的方法调用 使用new构造函数调用函数 作为函数方法调用函数(call、apply)","path":"2018/07/20/this/","date":"07-20","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc90e8616022f?w=1920&h=1080&f=jpeg&s=84587"},{"title":"认识React","text":"前言React作为Facebook 内部开发 Instagram 的项目中，是一个用来构建用户界面的优秀 JS 库，于 2013 年 5 月开源。作为前端的三大框架之一，React的应用可以说是非常的广泛，包括BAT在内的许多大公司很多项目都是基于其开发的。 Vue：除了VDom之外，Vue的响应性能和React相比还是有很大的区别，无论是本身的语法层面还是外围的第三方支持软件，总之，迁移起来不会是那么容易的事情。 但是作为一名热爱前端的技术人员,学习优秀的技术栈仿佛已经成了一种习惯,在这里结合阮一峰React以及对阮一峰老师15年的教程进行版本更新,简单介绍一下React的入门,本文中所有demo代码都以图片形式展示,目的是建议手打尝试，而不是直接复制，如需代码可以点击这里。使用 create-react-app 快速构建 React 开发环境create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 。 yarn add create-react-app -g create-react-app projectName cd projectName yarn start 然后打开浏览器输入http://localhost:3000/,就可以看到React的六芒星LOGO了。以下是React重要的部分 JSX – 允许我们编写类似HTML的语法 转换为lightweightJavaScript对象。虚拟DOM – 实际DOM的JavaScript表示。React.Component – 您创建新组件的方式render（方法） – 描述特定组件的 UI 外观 。ReactDOM.render – 将React组件\b渲染到DOM节点。state – 组件的内部数据存储（对象）。constructor（this.state） – 建立组件初始 state(状态) 的方式。setState – 一种辅助方法，用于更新组件的 state(状态) 并重新渲染 UI。props – 从父组件传递给子组件的数据。propTypes – 允许您控制传递给子组件的某些 props(属性) 的存在或类型。defaultProps – 允许您为组件设置默认 props(属性) 。 组件的生命周期componentDidMount – 装载组件后触发componentWillUnmount – 在组件卸载之前触发getDerivedStateFromProps – 当组件装载时以及每当props 更改时触发。 用于在其 props(属性) 更改时更新组件的状态 事件onClickonSubmitonChange React的JSX语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 因为React没有vue那样的v-for一键循环，所以要自己手动用map来实现效果图: React组件嵌套组件以及数据传递子组件vue通过子组件中的props来传递数据,而React则是用this.props.attr来传递，注意，没有$符号!组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员.我们定义了一个arr,里面是2个标题标签,通过在ul模板中添加{arr}来实现效果(注意不是vue的””，两者不要搞混了) this.props.childrenthis.props.attr是取到组件传递过来的数据或属性，而this.props.children则表示组件的所有子节点,可以通过this.props.children.map来遍历出来验证。 React之PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 yarn add prop-typesimport PropTypes from ‘prop-types’ MyTitle中有一个title属性，他的值为一个字符串，我们可以通过MyTitle.propTypes来定义该组件中属性的类型.如果将title: PropTypes.string改为其他类型，就会报以下的错误。 React之ref同vue的ref作用一样，组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。图片放的太多了，在这里贴一下代码..请忽视开头说的话..1234567891011121314class App extends Component &#123; handleClick () &#123; this.refs.myTextInput.focus() &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;LikeButton/&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123; this.handleClick.bind(this) &#125;/&gt; &lt;/div&gt; ); &#125;&#125; 在这里需要强调的是，React的事件中如果不用剪头函数，那就要用bind来绑定this。 React之this.state以及点击事件React中的state就相当于vue里的data数据存储,而小程序的this.setData,大家懂的.. 12345678910111213141516171819class LikeButton extends Component &#123; state = &#123; liked: false &#125; handleClick () &#123; // console.log(this) this.setState(&#123; liked: !this.state.liked &#125;) &#125; render() &#123; const text = this.state.liked?&apos;liked&apos;:&apos;don\\&apos;t like&apos; return ( &lt;p onClick=&#123; () =&gt; this.handleClick() &#125;&gt; You &#123; text &#125; this.click to toggle &lt;/p&gt; ) &#125;&#125; 在这里定义一个text变量，通过state中的liked来判断text的值，然后再通过onClick点击事件来反复改变liked的值，效果可以自己通过代码实现看看，就是普通的MVVM模型。 React之实现双向数据绑定vue里面v-model一键实现的事情React又没有-0-，不过我们可以通过onChange事件来简单实现它，直接上代码.1234567891011121314151617181920class App extends Component &#123; state= &#123; value: &apos;Hello!&apos; &#125; handleChange (event) &#123; this.setState(&#123; value: event.target.value &#125;) &#125; render() &#123; const val = this.state.value return ( &lt;div className=&quot;App&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;val&#125; onChange=&#123;this.handleChange.bind(this)&#125;/&gt; &lt;p&gt;&#123; val &#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; React之组件生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount(): 在插入真实DOM之前调用 componentDidMount(): 在插入真实DOM之后调用 componentWillUpdate(object nextProps,object nextState): 在被重新渲染之前调用 componentDidUpdate(object prevProps, object prevState): 在被重新渲染之后调用 componentWillUnmount(): 在移除真实DOM之前调用 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 另外，组件的style属性的设置方式也值得注意，不能写成style=&quot;opacity:{this.state.opacity};&quot;`而要写成`style={`{opacity: this.state.opacity}`} 结语作为一个前端程序猿很不容易，前端的技术更新太快，都出现了“别更新了，老子学不动了”这类前端的梗。不过前端层出不穷的技术让我们看到了前端的未来，我们都是热于分享的人，希望正在学习的我也能够帮助到正在学习的你。 这些demo都在我的github,感兴趣的朋友可以clone下来看下，最近搭了一个个人blog,欢迎来踩，PC端主题一股科幻风有没有！！主题来自于hexo主题最后说一句！很重要！如果我的这篇文章帮助到了你，那你可以点个star再走嘛~一起upupup!!!","path":"2018/07/19/react/","date":"07-19","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc92b61924d6c?w=1920&h=1080&f=jpeg&s=174299"},{"title":"hexo搭建blog","text":"前期准备安装以下东西： 1.git 2.node 3.个人github配置 安装完上面几大重要东西以后，hexo的搭建开始进入正轨。 安装hexo 在vscode中本地创建一个文件夹blog文件夹，cd进入该目录，里面必须是空的! 在vscode中打开终端（命令行）,输入npm install -g hexo 或者 yarn add hexo -g 安装完成以后输入hexo -v会显示hexo的相关信息 此时hexo应已安装完成，在该目录下执行hexo init进行hexo初始化以及安装依赖，就会有下列文件产生。 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 github创建一个hexo的reporepo的仓库名必须是yourname.github.io这个格式，其中yourname是github个人账号名创建好以后，打开blog文件夹下的_config.yml配置文件，找到以下： deploy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repo: https://github.com/YourgithubName/YourgithubName.github.io.git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;branch: master 注意：冒号后面都是要带一个空格的cd进入blog目录 hexo clean //清除缓存 hexo generate hexo server 打开浏览器输入http://localhost:4000/ 就能看到初始blog了 上传到自己的github在blog目录下安装：npm install hexo-deployer-git –save执行命令： hexo clean hexo generate hexo deploy在首次deploy的时候，会要求输入github的username及passward 最后在浏览器中输入http://yourgithubname.github.io 就可以看到自己的博客了 修改blog主题以及配置hexo的默认主题很丑！！所以我们需要更换它的主题，themes可以在这里面找到自己想要的主题，也可以通过百度来找自己喜欢的风格主题 写文章hexo支持markdown的语法，因此很方面，可以通过hexo new ‘文章名’或者hexo new page ‘文件夹名’来创建文章md文件，也可以手动在文件夹下面添加。 到这里，简单的hexo博客搭建已经完成。最后，关于更换完主题后的相关配置，可以查看相关主题的配置文档，一般都会有详细的说明，这里就不多提了，好晚了~好困~~睡觉睡觉，祝自己好梦。","path":"2018/07/18/hexo/","date":"07-18","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc90f33c70d30?w=1920&h=1080&f=jpeg&s=249955"}]}