{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-18","excerpt":""},{"title":"","text":"你看，那个人又偷偷溜走了..","path":"about/index.html","date":"07-18","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-18","excerpt":""}],"posts":[{"title":"React加载stylus文件之eject","text":"上篇知道了如何自定义配置webpack,接下来就让我们用简单一些的方法来实现使用stylus等功能。安装stylus依赖：1yarn add stylus stylus-loader 在webpack配置依赖，如果要手动配置webpack的话，React必须先把配置Eject出来：1yarn run eject react-cli会询问你是否执行操作，并提示你这个操作是不可逆的。输入y继续这个时候如果eject的该项目是在本地的一个git仓库里的，而且这个仓库里还有文件未上传到远程。那么恭喜你，你eject会失败，它会告诉你必须要把本地这个仓库里的文件未更改的状态下才能把webpack配置eject出来。成功以后项目根目录下会弹射出一个config文件夹和一个scripts文件夹，同时package.json里的相关配置也会改变在弹射出来的config文件夹下找到webpack.config.dev.js:1234567891011找到module.rules.oneOf,里面有一个css的配置项，把styl加进去:test: /\\.(css|styl)$/,然后在use中加入以下配置代码：&#123; loader: require.resolve(&apos;stylus-loader&apos;), options: &#123; sourceMap: true &#125;&#125;;滑到oneOf的最下面，找到exclude，将styl加进去：exclude: [/\\.(js|jsx|mjs)$/, /\\.html$/, /\\.json$/,/\\.styl$/], 然后记住要重新yarn安装一下依赖，最后输入yarn start就能成功启动了(可以直接引入styl文件)，这个时候还会出现一个postcss的提示，原来他是一个强大的东西，autoprefixer也只是他其中的一个插件安装postcss-loader:1yarn add postcss-loader 最后就会惊喜的发现关于css的浏览器兼容性问题的浏览器前缀会自动帮你加上 我的demo地址","path":"2018/07/22/eject/","date":"07-22","excerpt":""},{"title":"React定制webpack 工作流","text":"不使用eject,自定义webpack配置使用stylus以及alias@别名和autoprefixer前缀 在项目根目录下新建一个scripts文件夹。 在scripts文件夹中新建customized-build.js、overrides-config.base.js、overrides-config.dev.js、overrides-config.prod.js四个文件 安装rewire来实现运行时动态替换react-scripts // yarn add rewire proxyquire –save 在customized-build.js中加入以下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243var rewire = require(&apos;rewire&apos;);var proxyquire = require(&apos;proxyquire&apos;);switch(process.argv[2]) &#123; case &apos;start&apos;: rewireModule(&apos;react-scripts/scripts/start.js&apos;, loadCustomizer(&apos;./overrides-config.dev&apos;)); break; case &apos;build&apos;: rewireModule(&apos;react-scripts/scripts/build.js&apos;, loadCustomizer(&apos;./overrides-config.prod&apos;)); break; default: console.log(&apos;customized-build only supports &quot;start&quot;, &quot;build&quot;, and &quot;test&quot; options.&apos;); process.exit(-1);&#125;function loadCustomizer(module) &#123; try &#123; return require(module); &#125; catch(e) &#123; if(e.code !== &quot;MODULE_NOT_FOUND&quot;) &#123; throw e; &#125; &#125; // If the module doesn&apos;t exist, return a // noop that simply returns the config it&apos;s given. return config =&gt; config;&#125;function rewireModule(modulePath, customizer) &#123; // Load the module with `rewire`, which allows modifying the // script&apos;s internal variables. let defaults = rewire(modulePath); // Reach into the module, grab its global &apos;config&apos; variable, // and pass it through the customizer function. // The customizer should *mutate* the config object, because // react-scripts imports the config as a `const` and we can&apos;t // modify that reference. let config = defaults.__get__(&apos;config&apos;); customizer(config);&#125; 安装poststylus,autoprefixer只是其中的一个插件，yarn add poststylus -D开发环境替换配置：stylus 和 alias(也就是vue中的@路径别名)，在dev.js文件中引入以下代码：12345678910111213const baseConfig = require(&apos;./overrides-config.base&apos;)module.exports = function(config) &#123; let alias = config.resolve.alias; alias[&quot;@&quot;] = baseConfig.rootPath; let loaderList = config.module.rules[1].oneOf; loaderList.splice(loaderList.length-1, 0, &#123; test: /\\.styl$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;] &#125;) config.plugins.push(baseConfig.stylusLoaderOptionsPlugin);&#125; 在base.js文件中引入以下代码：12345678910111213141516171819202122232425262728293031const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;)const poststylus = require(&apos;poststylus&apos;)const autoprefixer = require(&apos;autoprefixer&apos;)function resolve(dir) &#123; return path.join(__dirname, &apos;..&apos;, dir);&#125;module.exports.rootPath = resolve(&apos;src&apos;)module.exports.stylusLoaderOptionsPlugin = new webpack.LoaderOptionsPlugin(&#123; options: &#123; stylus: &#123; use: [ poststylus([ require(&apos;postcss-flexbugs-fixes&apos;), autoprefixer(&#123; browsers: [ &apos;&gt;1%&apos;, &apos;last 4 versions&apos;, &apos;Firefox ESR&apos;, &apos;not ie &lt; 9&apos;, // React doesn&apos;t support IE8 anyway ], flexbox: &apos;no-2009&apos;, &#125;) ]) ] &#125; &#125;&#125;); 安装stylus依赖，yarn add stylus stylus-loader –save 还需要创建一个config-overrides.prod.js文件具有相同的内容。开发过程中使用的是dev文件(例如npm start)，在构建期间使用prod文件(例如，npm run build) 最后，要让这些新代码生效，你需要更改package.json，调用这些新的脚本，而不是默认的react-scripts的脚本。要做到这一点，可以用以下方法替换“start”、“build”和“test”12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node scripts/customized-build start&quot;, &quot;build&quot;: &quot;node scripts/customized-build build&quot;, &quot;test&quot;: &quot;node scripts/customized-build test --env=jsdom&quot;,&#125;, 注意⚠️：每次修改配置文件都要重启一下yarn start","path":"2018/07/22/rmusic/","date":"07-22","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc91009dfd658?w=1920&h=1080&f=jpeg&s=266732"},{"title":"聊聊HTTPS","text":"HTTP实现原理：一个故事讲完https 什么是 HTTPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTP 与 HTTPS 的区别 HTTP 是明文传输，HTTPS 通过 SSL\\TLS 进行了加密 HTTP 的端口号是 80，HTTPS 是 443 HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费 HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。 为什么要使用 HTTPS 建立一个信息安全通道，来保证数据传输的安全 确认网站的真实性，防止钓鱼网站","path":"2018/07/21/https/","date":"07-21","excerpt":""},{"title":"this、apply、call、bind","text":"this、apply、call、bind这是一个面试经典问题，是ES5时代的一个坑，我们利用ES6的箭头函数可以极大的避免这个this指向错误的结果 ES5中，this的指向其实可以用一句话来概括，只要牢记这句话，犯错的概率就会大大降低。 this 永远指向最后调用它的那个对象 怎么改变this的指向改变 this 的指向一共有以下4种方法： 使用ES6的箭头函数 在函数内部定义一个that = this 使用apply、call、bind 使用new来实例化一个对象 12345678910111213141516var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function () &#123; this.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //this.func1 is not a function 上述题中很多人会想当然的觉得答案是输出”dance”，然而在不使用箭头函数的情况下，是会报错的。因为在this.func1()中的作用域是在setTimeout中而不是在func2中，因此最后调用 setTimeout 的对象是window，window中不存在func1函数，所以报错了 1. 箭头函数众所周知，ES6的箭头函数是可以避免ES5中使用this所遇到的指向错误的坑的。箭头函数的this始终指向上层作用域的this。1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( ()=&gt; &#123; this.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //dance 2. 在函数内部定义一个 that = this如果不使用箭头函数，那通常我们都会选择这种简单的方法，先在函数内部定义一个that，来把this的指向赋值给它，然后在这个函数的内部都使用这个that，这样this的指向就不会改变了。123456789101112131415161718var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; var that = this; setTimeout( function() &#123; that.func1() &#125;,1000) &#125;&#125;;xiaoming.func2() //dance 3. 使用apply、call、bind使用apply、call、bind函数也是可以改变this的指向的 使用apply1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.apply(xiaoming),1000) &#125;&#125;;xiaoming.func2() //dance 使用call1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.call(xiaoming),1000) &#125;&#125;;xiaoming.func2() //dance 使用bind1234567891011121314151617var habit = &quot;sing&quot;;var xiaoming = &#123; habit: &quot;dance&quot;, func1: function() &#123; console.log(this.habit) &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1() &#125;.bind(xiaoming)(),1000) &#125;&#125;;xiaoming.func2() //dance apply、call、bind区别 apply和call的区别:其实apply和call的区别不大，只是参入的第二个参数类型不同。 1234567891011call:var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.call(a,1,2) //3 1234567891011apply: var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.apply(a,[1,2]) //3 12345678910bind:var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.bind(a,1,2) 我们发现bind并没有输出，因为bind()方法是会创建一个新的函数，所以我们必须要手动去调用：123456789var a = &#123; name: &quot;123&quot;, fn: function (a,b) &#123; console.log( a + b ) &#125;&#125;var b = a.fnb.bind(a,1,2)() //3 JS中的函数调用方式JS中一共有4种调用方式： 作为一个函数调用 函数作为对象中的方法调用 使用new构造函数调用函数 作为函数方法调用函数(call、apply)","path":"2018/07/20/this/","date":"07-20","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc90e8616022f?w=1920&h=1080&f=jpeg&s=84587"},{"title":"认识React","text":"前言React作为Facebook 内部开发 Instagram 的项目中，是一个用来构建用户界面的优秀 JS 库，于 2013 年 5 月开源。作为前端的三大框架之一，React的应用可以说是非常的广泛，包括BAT在内的许多大公司很多项目都是基于其开发的。 Vue：除了VDom之外，Vue的响应性能和React相比还是有很大的区别，无论是本身的语法层面还是外围的第三方支持软件，总之，迁移起来不会是那么容易的事情。 但是作为一名热爱前端的技术人员,学习优秀的技术栈仿佛已经成了一种习惯,在这里结合阮一峰React以及对阮一峰老师15年的教程进行版本更新,简单介绍一下React的入门,本文中所有demo代码都以图片形式展示,目的是建议手打尝试，而不是直接复制，如需代码可以点击这里。使用 create-react-app 快速构建 React 开发环境create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。 create-react-app 自动创建的项目是基于 Webpack + ES6 。 yarn add create-react-app -g create-react-app projectName cd projectName yarn start 然后打开浏览器输入http://localhost:3000/,就可以看到React的六芒星LOGO了。以下是React重要的部分 JSX – 允许我们编写类似HTML的语法 转换为lightweightJavaScript对象。虚拟DOM – 实际DOM的JavaScript表示。React.Component – 您创建新组件的方式render（方法） – 描述特定组件的 UI 外观 。ReactDOM.render – 将React组件\b渲染到DOM节点。state – 组件的内部数据存储（对象）。constructor（this.state） – 建立组件初始 state(状态) 的方式。setState – 一种辅助方法，用于更新组件的 state(状态) 并重新渲染 UI。props – 从父组件传递给子组件的数据。propTypes – 允许您控制传递给子组件的某些 props(属性) 的存在或类型。defaultProps – 允许您为组件设置默认 props(属性) 。 组件的生命周期componentDidMount – 装载组件后触发componentWillUnmount – 在组件卸载之前触发getDerivedStateFromProps – 当组件装载时以及每当props 更改时触发。 用于在其 props(属性) 更改时更新组件的状态 事件onClickonSubmitonChange React的JSX语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写 因为React没有vue那样的v-for一键循环，所以要自己手动用map来实现效果图: React组件嵌套组件以及数据传递子组件vue通过子组件中的props来传递数据,而React则是用this.props.attr来传递，注意，没有$符号!组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员.我们定义了一个arr,里面是2个标题标签,通过在ul模板中添加{arr}来实现效果(注意不是vue的””，两者不要搞混了) this.props.childrenthis.props.attr是取到组件传递过来的数据或属性，而this.props.children则表示组件的所有子节点,可以通过this.props.children.map来遍历出来验证。 React之PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 yarn add prop-typesimport PropTypes from ‘prop-types’ MyTitle中有一个title属性，他的值为一个字符串，我们可以通过MyTitle.propTypes来定义该组件中属性的类型.如果将title: PropTypes.string改为其他类型，就会报以下的错误。 React之ref同vue的ref作用一样，组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。图片放的太多了，在这里贴一下代码..请忽视开头说的话..1234567891011121314class App extends Component &#123; handleClick () &#123; this.refs.myTextInput.focus() &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;LikeButton/&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123; this.handleClick.bind(this) &#125;/&gt; &lt;/div&gt; ); &#125;&#125; 在这里需要强调的是，React的事件中如果不用剪头函数，那就要用bind来绑定this。 React之this.state以及点击事件React中的state就相当于vue里的data数据存储,而小程序的this.setData,大家懂的.. 12345678910111213141516171819class LikeButton extends Component &#123; state = &#123; liked: false &#125; handleClick () &#123; // console.log(this) this.setState(&#123; liked: !this.state.liked &#125;) &#125; render() &#123; const text = this.state.liked?&apos;liked&apos;:&apos;don\\&apos;t like&apos; return ( &lt;p onClick=&#123; () =&gt; this.handleClick() &#125;&gt; You &#123; text &#125; this.click to toggle &lt;/p&gt; ) &#125;&#125; 在这里定义一个text变量，通过state中的liked来判断text的值，然后再通过onClick点击事件来反复改变liked的值，效果可以自己通过代码实现看看，就是普通的MVVM模型。 React之实现双向数据绑定vue里面v-model一键实现的事情React又没有-0-，不过我们可以通过onChange事件来简单实现它，直接上代码.1234567891011121314151617181920class App extends Component &#123; state= &#123; value: &apos;Hello!&apos; &#125; handleChange (event) &#123; this.setState(&#123; value: event.target.value &#125;) &#125; render() &#123; const val = this.state.value return ( &lt;div className=&quot;App&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;val&#125; onChange=&#123;this.handleChange.bind(this)&#125;/&gt; &lt;p&gt;&#123; val &#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; React之组件生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount(): 在插入真实DOM之前调用 componentDidMount(): 在插入真实DOM之后调用 componentWillUpdate(object nextProps,object nextState): 在被重新渲染之前调用 componentDidUpdate(object prevProps, object prevState): 在被重新渲染之后调用 componentWillUnmount(): 在移除真实DOM之前调用 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 另外，组件的style属性的设置方式也值得注意，不能写成style=&quot;opacity:{this.state.opacity};&quot;`而要写成`style={`{opacity: this.state.opacity}`} 结语作为一个前端程序猿很不容易，前端的技术更新太快，都出现了“别更新了，老子学不动了”这类前端的梗。不过前端层出不穷的技术让我们看到了前端的未来，我们都是热于分享的人，希望正在学习的我也能够帮助到正在学习的你。 这些demo都在我的github,感兴趣的朋友可以clone下来看下，最近搭了一个个人blog,欢迎来踩，PC端主题一股科幻风有没有！！主题来自于hexo主题最后说一句！很重要！如果我的这篇文章帮助到了你，那你可以点个star再走嘛~一起upupup!!!","path":"2018/07/19/react/","date":"07-19","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc92b61924d6c?w=1920&h=1080&f=jpeg&s=174299"},{"title":"hexo搭建blog","text":"前期准备安装以下东西： 1.git 2.node 3.个人github配置 安装完上面几大重要东西以后，hexo的搭建开始进入正轨。 安装hexo 在vscode中本地创建一个文件夹blog文件夹，cd进入该目录，里面必须是空的! 在vscode中打开终端（命令行）,输入npm install -g hexo 或者 yarn add hexo -g 安装完成以后输入hexo -v会显示hexo的相关信息 此时hexo应已安装完成，在该目录下执行hexo init进行hexo初始化以及安装依赖，就会有下列文件产生。 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 github创建一个hexo的reporepo的仓库名必须是yourname.github.io这个格式，其中yourname是github个人账号名创建好以后，打开blog文件夹下的_config.yml配置文件，找到以下： deploy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repo: https://github.com/YourgithubName/YourgithubName.github.io.git&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;branch: master 注意：冒号后面都是要带一个空格的cd进入blog目录 hexo clean //清除缓存 hexo generate hexo server 打开浏览器输入http://localhost:4000/ 就能看到初始blog了 上传到自己的github在blog目录下安装：npm install hexo-deployer-git –save执行命令： hexo clean hexo generate hexo deploy在首次deploy的时候，会要求输入github的username及passward 最后在浏览器中输入http://yourgithubname.github.io 就可以看到自己的博客了 修改blog主题以及配置hexo的默认主题很丑！！所以我们需要更换它的主题，themes可以在这里面找到自己想要的主题，也可以通过百度来找自己喜欢的风格主题 写文章hexo支持markdown的语法，因此很方面，可以通过hexo new ‘文章名’或者hexo new page ‘文件夹名’来创建文章md文件，也可以手动在文件夹下面添加。 到这里，简单的hexo博客搭建已经完成。最后，关于更换完主题后的相关配置，可以查看相关主题的配置文档，一般都会有详细的说明，这里就不多提了，好晚了~好困~~睡觉睡觉，祝自己好梦。","path":"2018/07/18/hexo/","date":"07-18","excerpt":"","preview":"https://user-gold-cdn.xitu.io/2018/7/24/164cc90f33c70d30?w=1920&h=1080&f=jpeg&s=249955"}]}